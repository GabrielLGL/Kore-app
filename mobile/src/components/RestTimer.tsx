import React, { useState, useEffect, useRef } from 'react'
import { View, Text, StyleSheet, Animated, TouchableOpacity, Platform } from 'react-native'
import { Audio } from 'expo-av'
import { useHaptics } from '../hooks/useHaptics'
import { spacing, borderRadius, fontSize } from '../theme'
import { useColors } from '../contexts/ThemeContext'
import type { ThemeColors } from '../theme'
import {
  scheduleRestEndNotification,
  cancelNotification,
} from '../services/notificationService'
import { createBeepSound } from '../utils/timerBeep'

interface Props {
  duration: number // en secondes
  onClose: () => void
  notificationEnabled?: boolean
  vibrationEnabled?: boolean // défaut true — triple vibration haptics à la fin
  soundEnabled?: boolean     // défaut true — beep 440Hz à la fin
}

/**
 * Composant Timer de repos automatique.
 * Désormais intégré au flux de la page pour ne pas chevaucher la liste.
 */
const RestTimer: React.FC<Props> = ({
  duration,
  onClose,
  notificationEnabled,
  vibrationEnabled = true,
  soundEnabled = true,
}) => {
  const colors = useColors()
  const styles = useStyles(colors)
  const haptics = useHaptics()
  const [timeLeft, setTimeLeft] = useState(duration)
  const timerRef = useRef<NodeJS.Timeout | null>(null)
  const hapticTimer1Ref = useRef<NodeJS.Timeout | null>(null)
  const hapticTimer2Ref = useRef<NodeJS.Timeout | null>(null)
  const closeTimerRef = useRef<NodeJS.Timeout | null>(null)
  const endTimeRef = useRef<number>(Date.now() + duration * 1000) // Heure de fin cible
  const animValue = useRef(new Animated.Value(50)).current // Animation de montée légère
  const progressAnim = useRef(new Animated.Value(1)).current
  const notificationIdRef = useRef<string | null>(null)
  const soundRef = useRef<Audio.Sound | null>(null)
  const progressAnimRef = useRef<Animated.CompositeAnimation | null>(null)
  // Refs pour éviter les stale closures dans finishTimer (appelé depuis setInterval)
  const vibrationEnabledRef = useRef(vibrationEnabled)
  const soundEnabledRef = useRef(soundEnabled)

  useEffect(() => { vibrationEnabledRef.current = vibrationEnabled }, [vibrationEnabled])
  useEffect(() => { soundEnabledRef.current = soundEnabled }, [soundEnabled])

  useEffect(() => {
    if (notificationEnabled) {
      scheduleRestEndNotification(duration)
        .then(id => {
          notificationIdRef.current = id
        })
        .catch(e => { if (__DEV__) console.warn('[RestTimer] scheduleRestEndNotification failed:', e) })
    }
    return () => {
      if (notificationIdRef.current) {
        cancelNotification(notificationIdRef.current)
        notificationIdRef.current = null
      }
    }
  }, [duration, notificationEnabled])

  // Cleanup son
  useEffect(() => {
    return () => {
      if (soundRef.current) {
        soundRef.current.unloadAsync()
        soundRef.current = null
      }
    }
  }, [])

  useEffect(() => {
    // Animation d'entrée
    Animated.spring(animValue, { toValue: 0, useNativeDriver: true }).start()

    // Barre de progression
    progressAnimRef.current = Animated.timing(progressAnim, { toValue: 0, duration: duration * 1000, useNativeDriver: false })
    progressAnimRef.current.start()

    // Logique du décompte basée sur Date.now() pour éviter le drift
    const updateTimer = () => {
      const now = Date.now()
      const remaining = Math.max(0, Math.ceil((endTimeRef.current - now) / 1000))

      setTimeLeft(remaining)

      if (remaining <= 0) {
        if (timerRef.current) clearInterval(timerRef.current)
        finishTimer()
      }
    }

    // Première mise à jour immédiate
    updateTimer()

    // Mise à jour toutes les 100ms pour un affichage fluide
    timerRef.current = setInterval(updateTimer, 100)

    return () => {
      if (timerRef.current) clearInterval(timerRef.current)
      if (hapticTimer1Ref.current) clearTimeout(hapticTimer1Ref.current)
      if (hapticTimer2Ref.current) clearTimeout(hapticTimer2Ref.current)
      if (closeTimerRef.current) clearTimeout(closeTimerRef.current)
      if (progressAnimRef.current) progressAnimRef.current.stop()
    }
  }, [])

  const finishTimer = () => {
    if (notificationIdRef.current) {
      cancelNotification(notificationIdRef.current)
      notificationIdRef.current = null
    }

    // Triple vibration forte (conditionnelle)
    if (vibrationEnabledRef.current) {
      haptics.onDelete()
      hapticTimer1Ref.current = setTimeout(() => haptics.onDelete(), 400)
      hapticTimer2Ref.current = setTimeout(() => haptics.onDelete(), 800)
    }

    // Son beep (conditionnel)
    if (soundEnabledRef.current) {
      createBeepSound()
        .then(sound => {
          soundRef.current = sound
          return sound.playAsync()
        })
        .catch(e => { if (__DEV__) console.warn('[RestTimer] sound playback error:', e) })
    }

    // Fermeture automatique après 1 secondes
    closeTimerRef.current = setTimeout(closeTimer, 1000)
  }

  const closeTimer = () => {
    if (notificationIdRef.current) {
      cancelNotification(notificationIdRef.current)
      notificationIdRef.current = null
    }

    Animated.timing(animValue, { toValue: 50, duration: 200, useNativeDriver: true }).start(() => {
      onClose()
    })
  }

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`
  }

  const timerColor = timeLeft <= 10 ? colors.warning : colors.text

  return (
    <Animated.View style={[styles.container, { transform: [{ translateY: animValue }] }]}>
      <TouchableOpacity style={styles.content} onPress={closeTimer} activeOpacity={0.9}>
        <View style={styles.left}>
          <Text style={styles.label}>REPOS EN COURS</Text>
          <Text style={[styles.timer, { color: timerColor }]}>{formatTime(timeLeft)}</Text>
        </View>
        <View style={styles.hintChip}>
          <Text style={styles.hint}>Ignorer</Text>
        </View>
      </TouchableOpacity>
    </Animated.View>
  )
}

export default RestTimer

function useStyles(colors: ThemeColors) {
  return StyleSheet.create({
    container: {
      marginHorizontal: spacing.md,
      marginBottom: spacing.sm,
      marginTop: spacing.xs,
      backgroundColor: colors.card,
      borderRadius: borderRadius.md,
      borderWidth: 1.5,
      borderColor: colors.primary,
      elevation: 8,
      overflow: 'hidden',
    },
    progressBarWrapper: {
      height: 4,
      backgroundColor: colors.cardSecondary,
      overflow: 'hidden',
    },
    progressBarFill: {
      backgroundColor: colors.primary,
      height: 3,
    },
    content: {
      paddingVertical: spacing.ms,
      paddingHorizontal: spacing.md,
      alignItems: 'center',
      flexDirection: 'row',
      justifyContent: 'space-between',
    },
    left: { flexDirection: 'column' },
    label: { color: colors.textSecondary, fontSize: fontSize.xs, fontWeight: 'bold', letterSpacing: 1 },
    timer: { fontSize: fontSize.xxl, fontWeight: 'bold', fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace' },
    hintChip: {
      backgroundColor: colors.surfaceOverlay,
      borderRadius: borderRadius.sm,
      paddingVertical: spacing.xs,
      paddingHorizontal: spacing.sm,
    },
    hint: { color: colors.textSecondary, fontSize: fontSize.xs, fontWeight: '600' },
  })
}
