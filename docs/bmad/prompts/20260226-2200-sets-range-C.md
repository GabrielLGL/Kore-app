<!-- v1.0 — 2026-02-26 -->
# Rapport — sets-range — Groupe C (Glue) — 20260226-2200

## Objectif
Câbler le range de séries de bout en bout :
validation → modal → hook → sauvegarde en DB.
Ce groupe dépend de A (schéma + modèle) et B (UI ExerciseTargetInputs).

## Fichiers concernés
1. `mobile/src/model/utils/validationHelpers.ts`
2. `mobile/src/components/ExercisePickerModal.tsx`
3. `mobile/src/hooks/useSessionManager.ts`
4. `mobile/src/screens/SessionDetailScreen.tsx`

## Contexte technique

### Nouveau champ DB (Groupe A)
`SessionExercise.setsTargetMax?: number` — colonne `sets_target_max` (number, optional) dans schema v24.

### Nouveau composant (Groupe B)
`ExerciseTargetInputs` a de nouveaux props optionnels :
- `setsMax?: string` — valeur du max
- `onSetsMaxChange?: (value: string) => void` — callback

### Flux actuel (à étendre)
```
SessionDetailScreen
  → ExercisePickerModal (onAdd: (exerciseId, sets, reps, weight) => void)
    → ExerciseTargetInputs (sets, reps, weight, callbacks)
  → useSessionManager.addExercise(exerciseId, sets, reps, weight, exercise)
    → database.write → SessionExercise.create({ setsTarget, repsTarget, weightTarget })
```

### Flux cible
```
SessionDetailScreen
  → ExercisePickerModal (onAdd: (exerciseId, sets, setsMax, reps, weight) => void)
    → ExerciseTargetInputs (sets, setsMax, reps, weight, callbacks)
  → useSessionManager.addExercise(exerciseId, sets, setsMax, reps, weight, exercise)
    → database.write → SessionExercise.create({ setsTarget, setsTargetMax, repsTarget, weightTarget })
```

## Étapes

### 1. `validationHelpers.ts` — Mettre à jour `validateWorkoutInput`

Signature actuelle :
```typescript
export function validateWorkoutInput(sets: string, reps: string, weight?: string): { valid: boolean; errors: string[] }
```

Ajouter un paramètre optionnel `setsMax`:
```typescript
export function validateWorkoutInput(
  sets: string,
  reps: string,
  weight?: string,
  setsMax?: string
): { valid: boolean; errors: string[] }
```

Règle de validation supplémentaire (si `setsMax` est fourni et non vide) :
- `setsMax` doit être un entier valide
- `parseInt(setsMax) >= parseInt(sets)` — le max doit être ≥ au min
- Sinon ajouter error : `"Le max de séries doit être ≥ au min"`

Garder la validation existante inchangée pour sets/reps/weight.

### 2. `ExercisePickerModal.tsx` — Ajouter state + passer au composant

**a) Ajouter `onAdd` avec `setsMax` dans la signature du prop :**
```typescript
// Avant
onAdd: (exerciseId: string, sets: string, reps: string, weight: string) => Promise<void>
// Après
onAdd: (exerciseId: string, sets: string, setsMax: string, reps: string, weight: string) => Promise<void>
```

**b) Ajouter state `targetSetsMax` :**
```typescript
const [targetSetsMax, setTargetSetsMax] = useState('')
```

**c) Mettre à jour `isFormValid` :**
```typescript
const isFormValid = useMemo(() => {
  return validateWorkoutInput(targetSets, targetReps, targetWeight, targetSetsMax).valid
}, [targetSets, targetReps, targetWeight, targetSetsMax])
```

**d) Mettre à jour `handleAdd` :**
```typescript
const handleAdd = async () => {
  if (!isAddValid || !selectedExerciseId) return
  await onAdd(selectedExerciseId, targetSets, targetSetsMax, targetReps, targetWeight)
}
```

**e) Passer `setsMax` et `onSetsMaxChange` à `ExerciseTargetInputs` :**
```tsx
<ExerciseTargetInputs
  sets={targetSets}
  setsMax={targetSetsMax}          // ← NOUVEAU
  reps={targetReps}
  weight={targetWeight}
  onSetsChange={setTargetSets}
  onSetsMaxChange={setTargetSetsMax}  // ← NOUVEAU
  onRepsChange={setTargetReps}
  onWeightChange={setTargetWeight}
  autoFocus
/>
```

**f) Reset `targetSetsMax` lors de la fermeture/réinitialisation :**
Chercher où `targetSets`, `targetReps`, `targetWeight` sont remis à `''` ou à `initialSets`, etc. et ajouter `setTargetSetsMax('')` au même endroit.

### 3. `useSessionManager.ts` — Mettre à jour `addExercise` et `updateTargets`

**`addExercise` :**
```typescript
// Avant
const addExercise = async (exerciseId: string, sets: string, reps: string, weight: string, exercise: Exercise)

// Après
const addExercise = async (exerciseId: string, sets: string, setsMax: string, reps: string, weight: string, exercise: Exercise)
```

Dans `database.write` → `create`, ajouter :
```typescript
se.setsTarget = parseIntegerInput(sets)
se.setsTargetMax = setsMax ? parseIntegerInput(setsMax) : undefined  // ← NOUVEAU
se.repsTarget = reps
se.weightTarget = parseNumericInput(weight)
```

**`updateTargets` :** (pour l'édition d'un exercice déjà dans la séance)
```typescript
// Chercher la signature de updateTargets et ajouter setsMax
se.setsTarget = setsVal
se.setsTargetMax = setsMaxVal  // ← NOUVEAU
se.repsTarget = targetReps
se.weightTarget = weightVal
```

Note : chercher aussi `prepareEditTargets` — il lit `setsTarget` pour pré-remplir le formulaire d'édition.
Ajouter : `setTargetSetsMax(sessionExercise.setsTargetMax?.toString() || '')`.
Vérifier que `targetSetsMax` existe bien dans le state du hook (sinon l'ajouter).

### 4. `SessionDetailScreen.tsx` — Mettre à jour `handleAddExercise`

Chercher le callback `handleAddExercise` qui est passé à `ExercisePickerModal` comme `onAdd`.
Mettre à jour sa signature pour inclure `setsMax` :
```typescript
// Avant
const handleAddExercise = async (exerciseId: string, sets: string, reps: string, weight: string) => {
  await addExercise(exerciseId, sets, reps, weight, exercise)
}

// Après
const handleAddExercise = async (exerciseId: string, sets: string, setsMax: string, reps: string, weight: string) => {
  await addExercise(exerciseId, sets, setsMax, reps, weight, exercise)
}
```

### 5. Tests à mettre à jour
- `mobile/src/hooks/__tests__/useSessionManager.test.ts` : trouver les appels à `addExercise` et `updateTargets`, ajouter `setsMax` (ex: `''` pour garder backward compat dans les tests existants).
- Ajouter un cas de test pour vérifier que `setsTargetMax` est bien sauvegardé quand `setsMax` est non vide.
- Si `ExercisePickerModal.test.tsx` existe : mettre à jour les appels mock de `onAdd`.

## Contraintes
- Mutations DB UNIQUEMENT dans `database.write()` (pitfall CLAUDE.md 3.1).
- Pas de `any` TypeScript.
- Pas de hardcoded colors.
- `parseIntegerInput` est dans `mobile/src/model/utils/databaseHelpers.ts`.
- `setsTargetMax` est `undefined` quand la valeur de `setsMax` est `''` (vide = pas de range).

## Critères de validation
- `npx tsc --noEmit` → zéro erreur
- `npm test` → zéro fail
- Flux E2E : ajouter exercice avec range "3-5" → `setsTarget=3`, `setsTargetMax=5` en DB.
- Flux E2E : ajouter exercice sans max → `setsTarget=3`, `setsTargetMax=undefined` en DB.

## Dépendances
- **Dépend de Groupe A** (schema + model : `setsTargetMax` field doit exister sur `SessionExercise`)
- **Dépend de Groupe B** (`ExerciseTargetInputs` doit avoir props `setsMax`/`onSetsMaxChange`)

## Statut
⏳ En attente
