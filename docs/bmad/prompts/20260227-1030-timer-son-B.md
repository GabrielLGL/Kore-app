<!-- v1.0 — 2026-02-27 -->
# Rapport — timer-son — Groupe B (Audio + RestTimer) — 20260227-1030

## Objectif
1. Installer `expo-av` pour la lecture audio in-app
2. Ajouter un fichier son (beep court) dans les assets
3. Modifier `RestTimer.tsx` pour accepter `vibrationEnabled` et `soundEnabled` comme props optionnelles, et les respecter à la fin du timer

## Fichiers concernés
- `mobile/src/components/RestTimer.tsx`
- `mobile/assets/sounds/timer-end.mp3` (à créer — fichier audio)
- `mobile/package.json` (via `npx expo install expo-av`)

## Contexte technique
- Stack : React Native Expo 52 / Fabric (New Architecture)
- `expo-av` : library officielle Expo pour lecture audio/vidéo. Installer avec `npx expo install expo-av` (depuis `mobile/`)
- Interface actuelle de RestTimer (`mobile/src/components/RestTimer.tsx`) :
  ```typescript
  interface Props {
    duration: number
    onClose: () => void
    notificationEnabled?: boolean
  }
  ```
- `finishTimer()` (ligne ~86) : déclenche actuellement la triple vibration haptics. C'est ici qu'on ajoute le son.
- `useHaptics()` de `mobile/src/hooks/useHaptics.ts` est déjà utilisé pour les vibrations. Condition sur `vibrationEnabled` pour l'activer/désactiver.
- Son : utiliser `Audio.Sound` de `expo-av`. Pattern :
  ```typescript
  import { Audio } from 'expo-av'
  const sound = new Audio.Sound()
  await sound.loadAsync(require('../../assets/sounds/timer-end.mp3'))
  await sound.playAsync()
  ```
  Décharger le son dans le cleanup (`sound.unloadAsync()`).
- **Le fichier MP3** : utiliser un fichier beep court (< 2 secondes). Si un fichier existe déjà dans `mobile/assets/`, l'utiliser. Sinon, créer `mobile/assets/sounds/timer-end.mp3` avec un beep standard (chercher un fichier libre de droits public domain ou en générer un simple).
  - Alternative si pas de fichier disponible : utiliser `Audio.Sound.createAsync` depuis une URI de son libre de droits (dernier recours).

## Étapes

### 1. Installer expo-av
```bash
cd mobile && npx expo install expo-av
```

### 2. Créer le dossier assets/sounds
```bash
mkdir -p mobile/assets/sounds
```
Ajouter un fichier `timer-end.mp3` (beep court, < 2s, libre de droits). Si unavailable, utiliser ce fichier public domain libre : copier un beep.mp3 minimal.

### 3. Modifier RestTimer.tsx
Ajouter 2 props optionnelles (défaut `true`) :
```typescript
interface Props {
  duration: number
  onClose: () => void
  notificationEnabled?: boolean
  vibrationEnabled?: boolean  // défaut true
  soundEnabled?: boolean      // défaut true
}
```

Dans le composant, accepter `vibrationEnabled = true` et `soundEnabled = true` par défaut (destructuring avec default values).

Ajouter la gestion du son :
```typescript
import { Audio } from 'expo-av'
// ...
const soundRef = useRef<Audio.Sound | null>(null)

// useEffect cleanup : décharger le son
useEffect(() => {
  return () => {
    if (soundRef.current) {
      soundRef.current.unloadAsync()
    }
  }
}, [])
```

Dans `finishTimer()`, conditionner :
- **Haptics** : appeler `haptics.onDelete()` uniquement si `vibrationEnabled !== false`
- **Son** : charger et jouer le son uniquement si `soundEnabled !== false`

### 4. Vérifier les types TypeScript

## Contraintes
- Ne pas casser : la logique existante du timer (countdown, notification, fermeture auto)
- Respecter : pas de `any`, cleanup de tous les refs/sounds (Known Pitfalls CLAUDE.md)
- Si `vibrationEnabled` est `undefined` → se comporter comme `true` (rétrocompatible)
- Si `soundEnabled` est `undefined` → se comporter comme `true`

## Critères de validation
- `npx tsc --noEmit` → zéro erreur
- `npm test` → zéro fail
- Manuel : timer qui se termine → son entendu + vibration
- Manuel : avec soundEnabled=false → pas de son
- Manuel : avec vibrationEnabled=false → pas de vibration

## Dépendances
Aucune dépendance sur le Groupe A (les props sont indépendantes du modèle User).
Le Groupe C dépend de ce groupe (pour connaître l'interface de RestTimer).

## Statut
✅ Résolu — 20260227-1130

## Résolution
Rapport do : docs/bmad/do/20260227-1030-feat-rest-timer-sound.md
