<!-- v1.0 — 2026-02-27 -->
# Rapport — Rate Limiting /api/subscribe — Groupe A — 20260227-0900

## Objectif

Implémenter le rate limiting sur l'endpoint `POST /api/subscribe` de la landing page Next.js.
Protéger contre le spam/abus : max 5 requêtes par heure par IP.
Zéro nouvelle dépendance npm — in-memory Map suffisant pour l'échelle d'une landing page.

## Fichiers concernés

- `web/src/lib/rateLimit.ts` — **À CRÉER** (helper réutilisable)
- `web/src/app/api/subscribe/route.ts` — **À MODIFIER** (intégration du rate limiting)

## Contexte technique

### Stack
- Next.js 15.1 App Router, TypeScript strict
- `web/` est le répertoire racine du projet web (distinct de `mobile/`)
- Pas de Redis, pas de KV store, pas de lib de rate limiting installée

### État actuel de route.ts
```typescript
// web/src/app/api/subscribe/route.ts
import { NextRequest, NextResponse } from "next/server";
import { getSupabase } from "@/lib/supabase";
import { getResend } from "@/lib/resend";
import { WelcomeEmail } from "@/emails/welcome";

export async function POST(request: NextRequest) {
  try {
    const { email, name } = await request.json();
    if (!email || !email.includes("@")) {
      return NextResponse.json({ error: "Email invalide" }, { status: 400 });
    }
    // ... upsert Supabase + envoi Resend ...
    return NextResponse.json({ success: true });
  } catch {
    return NextResponse.json({ error: "Erreur serveur" }, { status: 500 });
  }
}
```

### Pattern lib existant (imiter supabase.ts et resend.ts)
`web/src/lib/supabase.ts` et `web/src/lib/resend.ts` utilisent des singletons avec `let client`.

## Étapes

### 1. Créer `web/src/lib/rateLimit.ts`

```typescript
// In-memory rate limiter — acceptable for landing page scale.
// For production scale: upgrade to @upstash/ratelimit + Redis.

interface RateLimitEntry {
  count: number
  resetAt: number
}

const store = new Map<string, RateLimitEntry>()

// Cleanup entries older than 2h to avoid memory leaks
setInterval(() => {
  const now = Date.now()
  for (const [key, entry] of store.entries()) {
    if (now > entry.resetAt + 60 * 60 * 1000) {
      store.delete(key)
    }
  }
}, 60 * 60 * 1000)

interface RateLimitResult {
  allowed: boolean
  remaining: number
  resetAt: number
  limit: number
}

export function checkRateLimit(
  ip: string,
  limit = 5,
  windowMs = 60 * 60 * 1000
): RateLimitResult {
  const now = Date.now()
  const entry = store.get(ip)

  if (!entry || now > entry.resetAt) {
    store.set(ip, { count: 1, resetAt: now + windowMs })
    return { allowed: true, remaining: limit - 1, resetAt: now + windowMs, limit }
  }

  if (entry.count >= limit) {
    return { allowed: false, remaining: 0, resetAt: entry.resetAt, limit }
  }

  entry.count++
  return { allowed: true, remaining: limit - entry.count, resetAt: entry.resetAt, limit }
}

export function getClientIp(request: { headers: { get: (key: string) => string | null } }): string {
  const forwarded = request.headers.get("x-forwarded-for")
  if (forwarded) return forwarded.split(",")[0].trim()
  return request.headers.get("x-real-ip") ?? "unknown"
}
```

### 2. Modifier `web/src/app/api/subscribe/route.ts`

Ajouter en haut des imports :
```typescript
import { checkRateLimit, getClientIp } from "@/lib/rateLimit";
```

Dans la fonction `POST`, AVANT la validation email, ajouter :
```typescript
// Rate limiting: 5 req/hour/IP
const ip = getClientIp(request)
const rateLimit = checkRateLimit(ip)
const rateLimitHeaders = {
  "X-RateLimit-Limit": String(rateLimit.limit),
  "X-RateLimit-Remaining": String(rateLimit.remaining),
  "X-RateLimit-Reset": String(Math.ceil(rateLimit.resetAt / 1000)),
}

if (!rateLimit.allowed) {
  const retryAfter = Math.ceil((rateLimit.resetAt - Date.now()) / 1000)
  return NextResponse.json(
    { error: "Trop de tentatives. Réessayez dans une heure." },
    {
      status: 429,
      headers: {
        ...rateLimitHeaders,
        "Retry-After": String(retryAfter),
      },
    }
  )
}
```

Sur le retour final `NextResponse.json({ success: true })` :
```typescript
return NextResponse.json({ success: true }, { headers: rateLimitHeaders })
```

**Note :** Pas besoin d'ajouter les headers sur les réponses 400/500 — c'est optionnel et préférable de les omettre sur les erreurs de validation.

## Contraintes

- Ne pas casser : la logique Supabase upsert, l'envoi Resend, les messages d'erreur FR existants
- TypeScript strict — pas de `any`
- Ne pas installer de nouvelle dépendance npm
- Le fichier `rateLimit.ts` doit être dans `web/src/lib/` (pas dans `mobile/`)
- L'endpoint est dans `web/`, pas dans `mobile/` — ne pas confondre les deux projets

## Critères de validation

```bash
cd web && npx tsc --noEmit   # zéro erreur TS
```

Test manuel (après `npm run dev`) :
```bash
for i in {1..6}; do \
  curl -s -o /dev/null -w "%{http_code}\n" \
  -X POST http://localhost:3000/api/subscribe \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com"}'; \
done
# Attendu : 200 200 200 200 200 429
```

Vérifier headers :
```bash
curl -v -X POST http://localhost:3000/api/subscribe \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com"}' 2>&1 | grep -i "x-ratelimit\|retry-after"
```

## Dépendances

Aucune dépendance sur d'autres groupes.

## Statut

✅ Résolu — 20260227-0930

## Résolution
Rapport do : docs/bmad/do/20260227-0930-feat-rate-limit.md
