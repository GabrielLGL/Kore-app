<!-- v1.0 — 2026-02-23 -->
# Rapport — Coverage Tests — Groupe C (Écrans restants) — 20260223-1400

## Objectif
Écrire les tests unitaires pour les 3 écrans restants sans tests : ProgramsScreen, AssistantScreen, ChartsScreen. Ce sont des écrans complexes avec beaucoup d'interactions.

## Fichiers concernés
**À tester (créer les fichiers test) :**
- `mobile/src/screens/ProgramsScreen.tsx` → `mobile/src/screens/__tests__/ProgramsScreen.test.tsx`
- `mobile/src/screens/AssistantScreen.tsx` → `mobile/src/screens/__tests__/AssistantScreen.test.tsx`
- `mobile/src/screens/ChartsScreen.tsx` → `mobile/src/screens/__tests__/ChartsScreen.test.tsx`

**Ne PAS modifier :**
- Les fichiers source des screens (sauf export du composant Base si nécessaire)
- Les tests existants

## Contexte technique

### Pattern de test des screens
Le pattern standard est :
1. Le screen utilise `withObservables` pour injecter les données
2. Le composant **Base** (avant le HOC) accepte les props directement
3. On teste le composant Base avec des props mockées
4. Si le composant Base n'est pas exporté, ajouter `export` devant sa déclaration

### Mocks standard requis
```tsx
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  notificationAsync: jest.fn(),
  ImpactFeedbackStyle: { Light: 'Light', Medium: 'Medium', Heavy: 'Heavy' },
  NotificationFeedbackType: { Success: 'Success', Error: 'Error' },
}))

jest.mock('../../model/index', () => ({
  database: {
    write: jest.fn().mockImplementation(async (fn) => fn()),
    get: jest.fn().mockReturnValue({
      query: jest.fn().mockReturnValue({
        fetch: jest.fn().mockResolvedValue([]),
        fetchCount: jest.fn().mockResolvedValue(0),
      }),
      find: jest.fn(),
    }),
    batch: jest.fn().mockResolvedValue(undefined),
  },
}))

jest.mock('@react-navigation/native', () => ({
  useNavigation: () => ({
    navigate: jest.fn(),
    goBack: jest.fn(),
    setOptions: jest.fn(),
  }),
  useRoute: () => ({ params: {} }),
}))

// Mock pour DraggableFlatList (ProgramsScreen)
jest.mock('react-native-draggable-flatlist', () => {
  const { FlatList } = require('react-native')
  return {
    __esModule: true,
    default: FlatList,
    ScaleDecorator: ({ children }) => children,
  }
})

jest.mock('react-native-gesture-handler', () => ({
  GestureHandlerRootView: ({ children }) => children,
}))
```

### ProgramsScreen — Structure
- **Props :** `programs: Program[]`, `user: User | null`, `navigation: NavigationProp`
- **Composant :** `ProgramsScreen` (pas de suffixe Base — vérifier l'export)
- **Features :**
  - Liste des programmes avec drag-and-drop (DraggableFlatList)
  - Créer un programme (CustomModal avec TextInput)
  - Renommer un programme
  - Supprimer un programme (AlertDialog)
  - Onboarding (si user.onboardingCompleted === false)
- **Hooks utilisés :** `useHaptics()`, `useKeyboardAnimation()`, `useProgramManager()`
- **Cas de test :**
  1. Render sans programmes → affiche message vide ou onboarding
  2. Render avec programmes → affiche la liste
  3. Render avec user null → pas de crash
  4. Bouton "Créer" → ouvre le modal
  5. Labels en français

### AssistantScreen — Structure
- **Features :** Chat avec l'assistant AI (messages, input, envoi)
- **Props :** Probablement `user: User`, `exercises: Exercise[]`
- **Cas de test :**
  1. Render initial → affiche le champ d'entrée
  2. Render sans user → pas de crash
  3. Taper un message → le texte apparaît dans l'input
  4. Labels en français

### ChartsScreen — Structure
- **Features :** Graphiques de progression pour un exercice spécifique
- **Props :** Probablement basées sur route params (exerciseId)
- **Mock :** `react-native-chart-kit` → composants string
- **Cas de test :**
  1. Render avec données → affiche le graphique
  2. Render sans données → message "Aucune donnée"
  3. Labels en français

### Mock des données
```ts
const mockProgram = {
  id: 'p1',
  name: 'PPL 3j',
  position: 0,
  sessions: { observe: () => ({ subscribe: (cb) => { cb([]); return { unsubscribe: jest.fn() } } }) },
  update: jest.fn(),
  destroyPermanently: jest.fn(),
}

const mockUser = {
  id: 'u1',
  name: 'Test',
  restDuration: 90,
  timerEnabled: true,
  onboardingCompleted: true,
  aiProvider: 'offline',
  aiApiKey: null,
  update: jest.fn(),
}

const mockNavigation = {
  navigate: jest.fn(),
  goBack: jest.fn(),
  setOptions: jest.fn(),
  addListener: jest.fn().mockReturnValue(jest.fn()),
}
```

## Étapes
1. Lire chaque screen source EN ENTIER pour comprendre les props, les exports, et les interactions
2. Si le composant Base n'est pas exporté, ajouter `export` devant la déclaration
3. Créer le fichier test avec les mocks standard
4. Pour ProgramsScreen : mocker `useProgramManager()` qui est un hook custom complexe
5. Pour AssistantScreen : mocker le service AI et le state du chat
6. Écrire 4-6 tests par screen
7. Lancer `cd mobile && npx jest --testPathPattern="screens/__tests__/(Programs|Assistant|Charts)" --no-coverage`
8. Corriger les erreurs
9. Lancer `cd mobile && npx jest --coverage --no-cache` pour vérifier le gain

## Contraintes
- Ne pas casser les tests existants (847 tests passent)
- Utiliser `@testing-library/react-native`
- Pas de `any`
- Mock les dépendances lourdes (DraggableFlatList, chart-kit, gesture-handler)
- Les descriptions de tests en français
- Si un screen est trop complexe à tester entièrement, se concentrer sur le render et les cas edge (null props, empty arrays)

## Critères de validation
- `npx tsc --noEmit` → zéro erreur
- `npm test` → zéro fail
- Au moins 3 tests par screen

## Dépendances
Aucune dépendance — ce groupe est autonome.

## Statut
✅ Résolu — 20260223-1600

## Résolution
Rapport do : docs/bmad/do/20260223-1600-test-remaining-screens.md
