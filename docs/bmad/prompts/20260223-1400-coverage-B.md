<!-- v1.0 — 2026-02-23 -->
# Rapport — Coverage Tests — Groupe B (ProgramGenerator) — 20260223-1400

## Objectif
Écrire les tests unitaires pour les modules du ProgramGenerator local (logique de génération de programmes hors-ligne). Ces fichiers contiennent de la logique pure ou avec accès DB, et sont critiques pour le business.

## Fichiers concernés
**À tester (créer les fichiers test) :**
- `mobile/src/services/ai/programGenerator/volumeCalculator.ts` → `mobile/src/services/ai/programGenerator/__tests__/volumeCalculator.test.ts`
- `mobile/src/services/ai/programGenerator/sessionBuilder.ts` → `mobile/src/services/ai/programGenerator/__tests__/sessionBuilder.test.ts`
- `mobile/src/services/ai/programGenerator/exerciseSelector.ts` → `mobile/src/services/ai/programGenerator/__tests__/exerciseSelector.test.ts`
- `mobile/src/services/ai/programGenerator/tables.ts` → `mobile/src/services/ai/programGenerator/__tests__/tables.test.ts`

**Fichier test existant à ne PAS modifier :**
- `mobile/src/services/ai/programGenerator/__tests__/splitStrategy.test.ts` (déjà 100%)

**Fichier types (pas de test nécessaire, mais à lire pour comprendre les interfaces) :**
- `mobile/src/services/ai/programGenerator/types.ts`

## Contexte technique

### Architecture du ProgramGenerator
Le ProgramGenerator suit un pipeline :
1. `splitStrategy.ts` → détermine le type de split (full_body, PPL, etc.) ✅ testé
2. `volumeCalculator.ts` → calcule le volume hebdo par muscle
3. `exerciseSelector.ts` → sélectionne les exercices depuis la DB
4. `sessionBuilder.ts` → assemble les sessions complètes
5. `tables.ts` → tables de référence (constantes)
6. `index.ts` → orchestrateur (appelle tout dans l'ordre)

### Types clés (de types.ts)
```ts
type MuscleGroup = 'chest' | 'back' | 'shoulders' | 'biceps' | 'triceps' | 'quads' | 'hamstrings' | 'glutes' | 'calves' | 'core' | 'traps'
type SplitType = 'full_body' | 'half_body' | 'push_pull' | 'push_pull_legs' | 'split'

interface UserProfile {
  goal: 'hypertrophy' | 'strength' | 'fat_loss' | 'general_fitness'
  level: 'beginner' | 'intermediate' | 'advanced'
  daysPerWeek: 2 | 3 | 4 | 5 | 6
  minutesPerSession: number
  equipment: Equipment[]
  injuries: BodyZone[]
  posturalIssues: boolean
}
```

### Pattern de test existant (splitStrategy.test.ts)
```ts
import { determineSplit, buildWeeklySchedule } from '../splitStrategy'
import type { UserProfile } from '../types'

const baseProfile: UserProfile = {
  goal: 'hypertrophy',
  level: 'beginner',
  daysPerWeek: 3,
  minutesPerSession: 60,
  equipment: ['barbell', 'dumbbell'],
  injuries: [],
  posturalIssues: false,
}

describe('determineSplit', () => {
  it('débutant + daysPerWeek ≤ 4 → full_body', () => {
    const profile = { ...baseProfile, level: 'beginner', daysPerWeek: 4 }
    expect(determineSplit(profile)).toBe('full_body')
  })
})
```

### volumeCalculator.ts — Exports à tester
- `calcWeeklyVolumeByMuscle(profile: UserProfile): Record<MuscleGroup, number>` — logique pure
  - Cas : goal × level → volume de base
  - Cas : minutesPerSession < 45 → muscles d'isolation supprimés
  - Cas : posturalIssues = true → boost chaîne postérieure (back, glutes, core) ×1.3
- `distributeVolumeToSessions(weeklyVolume, schedule): Record<MuscleGroup, number>[]` — logique pure
  - Cas : répartition équitable des séries entre sessions
  - Cas : MAX_SETS_PER_MUSCLE_PER_SESSION respecté

### tables.ts — Exports à tester
- `WEEKLY_VOLUME_TABLE` — vérifier structure et valeurs
- `PARAMS_TABLE` — vérifier structure et valeurs
- `SPLIT_BY_FREQUENCY` — vérifier mapping fréquence → split
- `MUSCLES_BY_PATTERN` — vérifier groupements push/pull/legs/core
- `MAX_TOTAL_SETS_PER_SESSION`, `MAX_SETS_PER_MUSCLE_PER_SESSION` — vérifier bornes

### exerciseSelector.ts — Exports à tester
- `selectExercisesForSession(musclesWithSets, profile, db)` — nécessite mock DB
  - Mock `db.get('exercises').query().fetch()` → retourne tableau d'exercices
  - Cas : filtre par equipment valide
  - Cas : respecte les injuries (exclut exercises des zones blessées)
  - Cas : ordonne par nervousDemand décroissant

### sessionBuilder.ts — Exports à tester
- `buildSession(dayIndex, musclesWithSets, profile, db, splitType)` — nécessite mock DB
  - Cas : construit une PGGeneratedSession valide
  - Cas : totalSets ≤ MAX_TOTAL_SETS_PER_SESSION
  - Cas : estimatedMinutes calculé correctement

### Mock DB pattern pour exerciseSelector et sessionBuilder
```ts
const mockExercises = [
  {
    id: 'e1', name: 'Développé couché',
    primaryMuscle: 'Pecs', secondaryMuscle: 'Triceps',
    equipment: 'Barbell', bodyZone: null,
  },
  // ... plus d'exercices
]

const mockDB = {
  get: jest.fn().mockReturnValue({
    query: jest.fn().mockReturnValue({
      fetch: jest.fn().mockResolvedValue(mockExercises),
    }),
  }),
} as unknown as Database
```

**IMPORTANT :** Les exercices en DB ont des noms FR (primaryMuscle: "Pecs", "Dos", etc.) mais le ProgramGenerator travaille avec des MuscleGroups EN (chest, back, etc.). Il y a des mappings `MUSCLE_TO_DB` et `EQUIPMENT_TO_DB` dans `types.ts`.

## Étapes
1. Lire chaque fichier source en entier pour comprendre les exports et la logique
2. Lire `types.ts` et `tables.ts` pour les constantes et interfaces
3. Créer `tables.test.ts` — tests simples sur les constantes
4. Créer `volumeCalculator.test.ts` — tests de logique pure
5. Créer `exerciseSelector.test.ts` — tests avec mock DB
6. Créer `sessionBuilder.test.ts` — tests avec mock DB
7. Lancer `cd mobile && npx jest --testPathPattern="programGenerator/__tests__" --no-coverage`
8. Corriger les erreurs
9. Lancer `cd mobile && npx jest --coverage --no-cache` pour vérifier le gain

## Contraintes
- Ne pas casser les tests existants (847 tests passent)
- Pas de `any` dans les types
- Les tests doivent être déterministes (pas de random non seedé)
- Mock la DB proprement (ne pas importer la vraie DB)
- Écrire les descriptions de tests en français

## Critères de validation
- `npx tsc --noEmit` → zéro erreur
- `npm test` → zéro fail
- Coverage des 4 fichiers > 80% chacun

## Dépendances
Aucune dépendance — ce groupe est autonome.

## Statut
⏳ En attente
